
Stuff Below is Left Over, Possibly to be Used in Extensions to be Done Later
=============================================================================

Values functions
-----------------

After doing this, we compute the discounted expected values obtained for
the two consumers by using the pairs :math:`P, d` that we have computed
for the value functions.

We compute the value functions :math:`x_t' P x_t + d` (I might have a
sign off here!) for the two :math:`P,d` pairs at the **same** dates
along the income simulation. But we choose the states for two
hypothetical consumer in the following peculiar way.

We give each consumer the same income :math:`y_t` and the pertinent
shock :math:`a_t` or :math:`\epsilon_t`, depending on whether it is the
“innovation representation” or the “original representation” consumer.

But we give **both** of these hypothetical consumers the :math:`b_t` of
the “innovation representation” consumer. We then record the discounted
present values for these two.

Thus, the **state** vectors :math:`x_t` are different for the two
consumers **only** because one sees :math:`a_t` while the other (better
informed) consumer sees :math:`\epsilon_t` – they both have the same
:math:`b_t`, namely, that of the “innovations representation” consumer.

.. code-block:: python3

    S, T = 10, 100
    
    ν_seq = np.random.normal(size=T+1)
    ϵ_seq = σϵ * ν_seq
    
    y_seq = np.empty(T+1)
    y_seq[0] = 100 # initial state
    for i in range(T):
        y_seq[i+1] = y_seq[i] + ϵ_seq[i+1] - ϵ_seq[i] /  β

.. code-block:: python3

    # Calculate innovations
    a_seq = np.zeros(T+1)
    for i in range(1, T+1):
        a_seq[i] += β ** i * a_seq[0]
        for j in range(i):
            a_seq[i] += β ** j * (y_seq[i-j] - y_seq[i-j-1])

.. code-block:: python3

    plt.plot(range(T+1), ϵ_seq, label="ϵ")
    plt.plot(range(T+1), a_seq, label="a")
    plt.legend()





Here we confirm that the constructed innovations generate the same
income sequence.

.. code-block:: python3

    ya_seq = np.empty(T+1)
    ya_seq[0] = 100 # initial state
    for i in range(T):
        ya_seq[i+1] = ya_seq[i] + a_seq[i+1] - β * a_seq[i]
        
    np.max(np.abs(ya_seq - y_seq)) < 1e-10



============================




Stuff Below is Left Over, Possibly to be Used in Extensions to be Done Later
=============================================================================

Values functions
-----------------

After doing this, we compute the discounted expected values obtained for
the two consumers by using the pairs :math:`P, d` that we have computed
for the value functions.

We compute the value functions :math:`x_t' P x_t + d` (I might have a
sign off here!) for the two :math:`P,d` pairs at the **same** dates
along the income simulation. But we choose the states for two
hypothetical consumer in the following peculiar way.

We give each consumer the same income :math:`y_t` and the pertinent
shock :math:`a_t` or :math:`\epsilon_t`, depending on whether it is the
“innovation representation” or the “original representation” consumer.

But we give **both** of these hypothetical consumers the :math:`b_t` of
the “innovation representation” consumer. We then record the discounted
present values for these two.

Thus, the **state** vectors :math:`x_t` are different for the two
consumers **only** because one sees :math:`a_t` while the other (better
informed) consumer sees :math:`\epsilon_t` – they both have the same
:math:`b_t`, namely, that of the “innovations representation” consumer.

.. code-block:: python3

    S, T = 10, 100
    
    ν_seq = np.random.normal(size=T+1)
    ϵ_seq = σϵ * ν_seq
    
    y_seq = np.empty(T+1)
    y_seq[0] = 100 # initial state
    for i in range(T):
        y_seq[i+1] = y_seq[i] + ϵ_seq[i+1] - ϵ_seq[i] /  β

.. code-block:: python3

    # Calculate innovations
    a_seq = np.zeros(T+1)
    for i in range(1, T+1):
        a_seq[i] += β ** i * a_seq[0]
        for j in range(i):
            a_seq[i] += β ** j * (y_seq[i-j] - y_seq[i-j-1])

.. code-block:: python3

    plt.plot(range(T+1), ϵ_seq, label="ϵ")
    plt.plot(range(T+1), a_seq, label="a")
    plt.legend()





Here we confirm that the constructed innovations generate the same
income sequence.

.. code-block:: python3

    ya_seq = np.empty(T+1)
    ya_seq[0] = 100 # initial state
    for i in range(T):
        ya_seq[i+1] = ya_seq[i] + a_seq[i+1] - β * a_seq[i]
        
    np.max(np.abs(ya_seq - y_seq)) < 1e-10

